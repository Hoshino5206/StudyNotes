# 第一章

Hotspot虚拟机 
引用计数法：(当某些对象之间互相引用时)不能解决多个对象循环引用情况，会发生内存泄漏
可达性分析算法：

没有引用指向的对象就是垃圾

新生代：老年代 = 1：2

(取决于垃圾回收器)
新生代区域 eden：from Survivor: to Survivor = 8：1：1
原因：--------


新生代进入老年代对象的年龄(取决于垃圾回收器)：
- Parallel Scavenge 15 
- CMS是6
- G1 15

MinorGC = YGC
MajorGC = FGC
STW = stop the world 避免不了的，要看垃圾回收器

垃圾收集器
新生代收集器：Serial、ParNew、Parallel Scavenge
老年代收集器：Serial Old、CMS、Parallel Old
堆内存垃圾收集器：G1
1.8 默认的是 Paralle
1.9 默认的是 G1
G1 适用于 8/16G 以上的内存适用，清理垃圾时虽然 STW，但是是可控的.
CMS 并发但是不可控



Java内存模型即Java Memory Model，简称JMM。JMM定义了Java虚拟机(JVM)在计算机内存(RAM)中的工作方式。JVM是整个计算机虚拟模型，所以JMM是隶属于JVM的。

Java内存模型定义了多线程之间共享变量的可见性以及如何在需要的时候对共享变量进行同步。

volatile：保证多线程之间共享变量之间的可见性

底层原理：

volatile禁止指令重排

synchronized：



类加载分为以下 5 个步骤

- 加载：根据查找路径找到相应的 class 文件然后导入；
- 检查：检查加载的 class 文件的正确性；
- 准备：给类中的静态变量分配内存空间；
- 解析：虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用就理解为一个标示，而在直接引用直接指向内存中的地址；
- 初始化：对静态变量和静态代码块执行初始化工作。





##### 1. JVM 的主要组成部分
- 类加载器（ClassLoader）
- 运行时数据区（Runtime Data Area）
- 执行引擎（Execution Engine）
- 本地库接口（Native Interface）

组件的作用： 首先通过类加载器（ClassLoader）会把 Java 代码转换成字节码，运行时数据区（Runtime Data Area）再把字节码加载到内存中，而字节码文件只是 JVM 的一套指令集规范，并不能直接交个底层操作系统去执行，因此需要特定的命令解析器执行引擎（Execution Engine），将字节码翻译成底层系统指令，再交由 CPU 去执行，而这个过程中需要调用其他语言的本地库接口（Native Interface）来实现整个程序的功能。

##### 2.JVM 运行时数据区
- 程序计数器
- 虚拟机栈
- 本地方法栈
- 堆
- 方法区

有的区域随着虚拟机进程的启动而存在，有的区域则依赖用户进程的启动和结束而创建和销毁。

##### 3.JVM 的生命周期
声明周期起点是当一个java应用main函数启动时虚拟机也同时被启动，而只有当在虚拟机实例中的所有非守护进程都结束时，java虚拟机实例才结束生命（实例理解“当所有的非守护线程全部解说，jvm声明周期才结束”）

##### 4.JVM 的两种线程
一种叫守护线程，一种叫非守护线程（也叫普通线程），main函数就是个非守护线程，虚拟机的gc就是一个守护线程（虚拟机的gc（垃圾回收机制）就是一个典型的守护线程。）。java的虚拟机中，只要有任何非守护线程还没有结束，java虚拟机的实例都不会退出，所以即使main函数这个非守护线程退出，但是由于在main函数中启动的匿名线程也是非守护线程，它还没有结束，所以JVM没办法退出

##### 5.双亲委派

双亲委派机制：JVM在加载类时默认采用的是双亲委派机制。通俗的讲，就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依次递归，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。

理解：当一个Hello.class这样的文件要被加载时。不考虑我们自定义类加载器，首先会在AppClassLoader中检查是否加载过，如果有那就无需再加载了。如果没有，那么会拿到父加载器，然后调用父加载器的loadClass方法。父类中同理也会先检查自己是否已经加载过，如果没有再往上。注意这个类似递归的过程，直到到达Bootstrap classLoader之前，都是在检查是否加载过，并不会选择自己去加载。直到BootstrapClassLoader，已经没有父加载器了，这时候开始考虑自己是否能加载了，如果自己无法加载，会下沉到子加载器去加载，一直到最底层，如果没有任何加载器能加载，就会抛出ClassNotFoundException