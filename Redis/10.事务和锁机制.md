# 1. 事务命令

| 命令    | 说明         |
| :------ | :----------- |
| muitl   | 开启事务命令 |
| command | 普通命令     |
| discard | 在提交前取消 |
| exec    | 提交         |

注：discard只是结束本次事务，前2条语句已经执行，造成的影响仍然还在。

语句出错有两种情况： 

- 执行命令入队的语法有问题时，如果exec提交事务会报错，所有语句取消执行，对数据不造成影响。 
- 执行命令入队的语法没问题，但适用对象有问题(比如 zadd 操作list对象)，exec提交事务之后，会执行正确的语句，并跳过有不适当的语句，不会回滚，对数据会造成影响。
- 以上两种错误类似于：Java的**编译错误** 和 **运行时错误**（可以类似这样理解）

# 2. 乐观锁和悲观锁

**乐观锁(Optimistic Lock),** 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。**乐观锁适用于多读的应用类型，这样可以提高吞吐量**。Redis就是利用这种check-and-set机制实现事务的。

**悲观锁(Pessimistic Lock)**, 顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。**传统的关系型数据库里边就用到了很多这种锁机制**，比如**行锁**，**表锁**等，**读锁**，**写锁**等，都是在做操作之前先上锁。

Redis的事务中启用的是**乐观锁**，只负责监测key没有被改动，如果在事务中发现key被改动，则取消事务。使用watch命令来监控一个或多个key，使用unwatch命令来取消监控所有key。

```bash
# 示例
watch key
muitl
操作数据...
exec
unwatch
```

模拟抢票，场景：用户买一张票，扣掉100元

```bash
# 在zhangsan买票过程中，在提交事务前一瞬间，有人成功买到票，ticket已经改变(即使ticket还有票)，导致zhangsan抢票失败。
127.0.0.1:6379> watch ticket
OK
127.0.0.1:6379> multi
OK
127.0.0.1:6379> decr ticket
QUEUED
127.0.0.1:6379> decrby zhangsan 100
QUEUED
127.0.0.1:6379> exec
(nil)
127.0.0.1:6379> get zhangsan
"1000"
127.0.0.1:6379> get ticket
"2"
127.0.0.1:6379> unwatch
OK


# lisi在买票整个过程都没有人抢票，所以lisi一次抢票成功。
127.0.0.1:6379> watch ticket
OK
127.0.0.1:6379> multi
OK
127.0.0.1:6379> decrby lisi 100
QUEUED
127.0.0.1:6379> decr ticket
QUEUED
127.0.0.1:6379> exec
1) (integer) 700
2) (integer) 1
127.0.0.1:6379> unwatch
```
